<!-- See https://www.sanity.io/guides/server-side-rendering-deno-react -->

<script src="https://unpkg.com/monaco-editor@latest/min/vs/loader.js"></script>

<script type="module">
import * as esbuild from "https://cdn.jsdelivr.net/npm/esbuild-wasm@0.14.1/esm/browser.min.js";
const esbuildPromise = Promise.resolve(esbuild.initialize({
  wasmURL: 'https://cdn.jsdelivr.net/npm/esbuild-wasm@0.14.1/esbuild.wasm',
}).then(() => esbuild));

require.config({
  paths: {
    'vs': 'https://unpkg.com/monaco-editor@latest/min/vs'
  }
});

const proxy = URL.createObjectURL(new Blob([`
  self.MonacoEnvironment = {
    baseUrl: 'https://unpkg.com/monaco-editor@latest/min/'
  };
  importScripts('https://unpkg.com/monaco-editor@latest/min/vs/base/worker/workerMain.js');
`], { type: 'text/javascript' }));

window.MonacoEnvironment = { getWorkerUrl: () => proxy };

//const theme = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'vs-dark' : undefined;
const theme = 'vs-dark';

let value = `
import { flavors } from "https://gist.githubusercontent.com/BurntCaramel/d9d2ca7ed6f056632696709a2ae3c413/raw/0234322cf854d52e2f2bd33aa37e8c8b00f9df0a/1.js";

const a = 1 + 1 + flavors.length;

export function Example() {
    return a + 4;
}
`.trim();

const prefix = `
//import React from "https://cdn.jsdelivr.net/npm/react@17.0.2/umd/react.profiling.min.js/+esm";
//import ReactDOM from "https://cdn.jsdelivr.net/npm/react-dom@17.0.2/umd/react-dom.profiling.min.js/+esm";
//import ReactDOMServer from "https://cdn.jsdelivr.net/npm/react-dom@17.0.2/umd/react-dom-server.profiling.min.js/+esm";
import React, { useReducer, useCallback, useEffect, useState, useMemo } from "https://jspm.dev/react@17.0.2";
import ReactDOM from "https://jspm.dev/react-dom@17.0.2/profiling";
import ReactDOMServer from "https://jspm.dev/react-dom@17.0.2/server";
`;

const suffix = `
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);

    this.state = { error: null };
  }

  static getDerivedStateFromError(error) {
    return { error };
  }

  render() {
    if (this.state.error) {
      return <div class="flex h-full justify-center items-center text-white bg-red-700"><div>Error: {this.state.error.message}</div></div>;
    }

    return <>{this.props.children}</>;
  }
}

export function Example() {
  const clientAppEl = document.getElementById('clientApp');

  const wrapped = <React.Profiler id="App" onRender={(id, phase, actualDuration, baseDuration, startTime, commitTime, interactions) => {
    clientAppEl.dispatchEvent(new CustomEvent('DID_RENDER', { detail: { id, phase, actualDuration, baseDuration, startTime, commitTime, interactions } }));
  }}>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </React.Profiler>;

  clientAppEl.dispatchEvent(new CustomEvent('RESET'));
  ReactDOM.render(wrapped, clientAppEl);
  clientAppEl.addEventListener('RESET', () => {
    ReactDOM.unmountComponentAtNode(clientAppEl);
  }, { once: true });

  try {
    return ReactDOMServer.renderToString(wrapped);
  } catch (error) {
    return \`<!-- Uncaught error: \${error.message} -->\n<div class="flex h-full justify-center items-center text-white bg-red-700"><div>Error: \${error.message}</div></div>\`;
  }
}
`;

value = `
import { flavors } from "https://gist.githubusercontent.com/BurntCaramel/d9d2ca7ed6f056632696709a2ae3c413/raw/0234322cf854d52e2f2bd33aa37e8c8b00f9df0a/1.js";

const a = 1 + 1 + flavors.length;

function useTick() {
  return useReducer(n => n + 1, 0);
}

function useDebouncer(duration) {
  const [count, tick] = useTick();

  const callback = useMemo(() => {
    let timeout = null;
    function clear() {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
    }
    return () => {
      clear()
      timeout = setTimeout(tick, duration);
      return clear;
    };
  }, [duration, tick]);

  return [count, callback];
}

export default function App() {
  const [count, tick] = useDebouncer(1000);
  return <>
    <div>Hello!! {flavors.join(" ")}</div>
    <button onClick={tick}>Click</button>
    <div>{count}</div>
  </>;
}
`.trim();

value = `
import { flavors } from "https://gist.githubusercontent.com/BurntCaramel/d9d2ca7ed6f056632696709a2ae3c413/raw/0234322cf854d52e2f2bd33aa37e8c8b00f9df0a/1.js";

const a = 1 + 1 + flavors.length;

function useTick() {
  return useReducer(n => n + 1, 0);
}

function useDebouncer(duration) {
  const [count, tick] = useTick();

  const callback = useMemo(() => {
    let timeout = null;
    function clear() {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
    }
    return () => {
      clear()
      timeout = setTimeout(tick, duration);
      return clear;
    };
  }, [duration, tick]);

  return [count, callback];
}

const cache = new Map();
function cachedWork(key, work) {
  const existing = cache.get(key);
  if (existing) return existing;

  const created = work();
  cache.set(key, created);
  return created;
}

function useCacheKey() {
  const [key] = useState(() => Object(Symbol(Math.random())));
  console.log('key', key);;
  return key;
}

function useCached(work) {
  const key = useCacheKey();
  return cachedWork(key, work);
}

function useAsyncCached(work) {
  const key = useCacheKey();
  console.log(key);

  let record = cache.get(key);

  console.log('record', record)

  if (record === undefined) {
    record = {
      status: 'pending',
      result: undefined
    };
    cache.set(key, record);

    const promise = work()
      .then(result => {
        record.status = 'succeeded';
        record.result = result;
      })
      .catch(error => {
        record.status = 'failed';
        record.result = error;
      });
    record.promise = promise;
  }

  if (record.status === 'pending') {
    throw record.promise;
  }

  if (record.status === 'failed') {
    throw record.result;
  }

  return record.result;
}

function SHAComponent() {
  const sha = useAsyncCached(() =>
    crypto.subtle.digest('SHA-256', new TextEncoder().encode('abc'))
      .then(arrayBuffer => {
        return Array.from(new Uint8Array(arrayBuffer), chunk => chunk.toString(16).padStart(2, '0')).join('');
      })
  );

  return <div>{sha}</div>;
}

export default function App() {
  const [count, tick] = useDebouncer(1000);
  return <>
    <div>Hello!! {flavors.join(" ")}</div>
    <button onClick={tick}>Click</button>
    <div>{count}</div>
  </>;
}
`.trim();

const types = fetch("https://workers.cloudflare.com/index.d.ts", { cache: 'force-cache' })
  .then((response) => response.text())
  .catch((err) => `// ${err.message}`);

require(["vs/editor/editor.main"], function () {
  const typescript = monaco.languages.typescript;
  for (const lang of [typescript.typescriptDefaults, typescript.javascriptDefaults]) {
    lang.setCompilerOptions({
      noSemanticValidation: true,
      noSyntaxValidation: false
    });
    lang.setCompilerOptions({
      target: monaco.languages.typescript.ScriptTarget.ESNext,
      allowNonTsExtensions: true,
      allowJs: true,
    });
    /* FIXME: types.then(([uri, content]) => lang.addExtraLib(content, uri)); */
  }
  const input = monaco.editor.create(document.getElementById('input'), {
    language: 'typescript',
    model: monaco.editor.createModel(value, 'typescript', 'ts:worker.ts'),
    value,
    theme,
    minimap: {
      enabled: false
    }
  });
  const htmlOutput = monaco.editor.create(document.getElementById('htmlOutput'), {
    language: 'html',
    value: '',
    theme,
    readOnly: true,
    minimap: {
      enabled: false
    }
  });
  const statusEl = document.getElementById('status');
  const resultEl = document.getElementById('result');
  const onEdit = () => {
    const body = input.getValue();

    const encoder = new TextEncoder();
    const data = encoder.encode(body);
    crypto.subtle.digest('SHA-256', data).then(hash => {
      const hex = Array.from(new Uint8Array(hash), chunk => chunk.toString(16).padStart(2, '0')).join('');
      statusEl.textContent = `SHA256: ${hex}`;
    });

    esbuildPromise
      .then(esbuild => {
        const httpPlugin = {
          name: 'http',
          setup(build) {
            // Intercept import paths starting with "http:" and "https:" so
            // esbuild doesn't attempt to map them to a file system location.
            // Tag them with the "http-url" namespace to associate them with
            // this plugin.
            build.onResolve({ filter: /^https?:\/\// }, args => ({
              path: args.path,
              namespace: 'http-url',
            }))

            // We also want to intercept all import paths inside downloaded
            // files and resolve them against the original URL. All of these
            // files will be in the "http-url" namespace. Make sure to keep
            // the newly resolved URL in the "http-url" namespace so imports
            // inside it will also be resolved as URLs recursively.
            build.onResolve({ filter: /.*/, namespace: 'http-url' }, args => ({
              path: new URL(args.path, args.importer).toString(),
              namespace: 'http-url',
            }))

            // When a URL is loaded, we want to actually download the content
            // from the internet. This has just enough logic to be able to
            // handle the example import from unpkg.com but in reality this
            // would probably need to be more complex.
            build.onLoad({ filter: /.*/, namespace: 'http-url' }, async (args) => {
              //console.log('loading', args.path);
              let contents = await fetch(args.path).then(res => res.text());
              //console.log('loaded', args.path, contents);
              return { contents }
            })
          },
        }

        const start = Date.now();

        //return esbuild.transform(body, { loader: 'jsx', format: 'iife', globalName: 'exports', plugins: [exampleOnResolvePlugin] }).then(content => content.code);
        return esbuild.build({
          bundle: true,
          stdin: {
            contents: `${prefix}\n${body ?? ""}\n${suffix}`,
            loader: 'jsx',
            sourcefile: 'main.jsx',
          },
          write: false,
          format: 'iife',
          globalName: 'exports',
          plugins: [httpPlugin]
        })
          .then(result => {
            const duration = Date.now() - start;
            if (result.outputFiles.length > 0) {
              return {
                code: new TextDecoder().decode(result.outputFiles[0].contents),
                duration,
                codeBytes: result.outputFiles[0].contents.length
              };
            } else {
              return {
                code: "",
                duration,
                codeBytes: 0
              };
            }
          })
      })
      .then(({ code, codeBytes, duration }) => {
        console.log("NEW CODE!");
        const executor = new Function(`${code}; return exports.Example();`);
        const result = executor();
        return new Map()
          .set('result', result)
          .set('error', '')
          .set('esbuildMs', duration.toString() + 'ms to compile')
          .set('esbuildBytes', (codeBytes / 1024).toFixed(2) + ' KB to download');
      })
      .catch((err) => {
        return new Map().set('error', 'Error ' + err.message);
      })
      .then(data => {
        for (const slotEl of resultEl.querySelectorAll('slot[name]')) {
          slotEl.textContent = data.get(slotEl.name) || '';
        }
        htmlOutput.getModel().setValue(data.get('result') || '');
      });

    /*fetch('/upload', { method: 'POST', body })
      .then(async (response) => {
        const content = await response.text();
        return response.ok ? content : '// ' + content.trimEnd().split('\n').join('\n// ');
      })
      .then((content) => output.getModel().setValue(content))
      .catch((err) => console.warn(err));*/
  };
  input.onDidChangeModelContent(onEdit);
  const model = input.getModel();
  model.setValue(input.getValue() + "\n");

  const clientAppEl = document.getElementById('clientApp');
  const reactRenderEl = document.querySelector('#clientResult slot[name="reactRenderDuration"]');
  let renderCount = 0;
  clientAppEl.addEventListener('DID_RENDER', ({ detail }) => {
    renderCount++;

    if (renderCount > 1000) {
      const previousCount = renderCount;
      setTimeout(() => {
        if (renderCount - previousCount > 100) {
          // Too many renders.
          // Abort client React app!
          clientAppEl.dispatchEvent(new CustomEvent('RESET'));

          reactRenderEl.textContent = `aborted due to infinite rendering loop!`;
        }
      }, 1000);
    }

    reactRenderEl.textContent = `last ${detail.actualDuration}ms; ${renderCount} times rendered`;
  });
});
</script>
<output id=status class="block text-xs opacity-50"></output>
<div class="flex">
  <output id=result class="block text-xs">
    <div class="text-red-500"><slot name=error></slot></div>
    <div>esbuild: <slot name=esbuildMs></slot>, <slot name=esbuildBytes></slot></div>
  </output>
  <div id="clientResult" class="ml-auto text-xs"><slot name=reactRenderDuration></slot></div>
</div>
<div class="flex-container" id="container" style="display: flex; min-height: 100vh;">
  <div id="input" style="flex: 1;"></div>
  <div class="flex-1 flex flex-col">
    <div id="clientApp" style="flex: 1;" class="bg-white text-black"></div>
    <div id="htmlOutput" style="flex: 1;"></div>
  </div>
</div>
